#include "CodeGenerator.h"
#include "HeaderAnalyzer.h"
#include <fstream>


CodeGenerator::CodeGenerator()
{

}

bool CodeGenerator::Generate(std::filesystem::path headerPath, std::string macroPath)
{
	if (!std::filesystem::exists(headerPath))
	{
		return false;
	}

	std::filesystem::path absolutePath = std::filesystem::absolute(headerPath);
	std::filesystem::path dirPath{ absolutePath.parent_path().string() + "\\generated" };
	bool ret = create_directory(dirPath);

	std::string generatedHeaderName = dirPath.string() + "\\" + headerPath.stem().string() + "_generated.h";
	std::ofstream headerFile(generatedHeaderName, std::ios::out);
	if (!headerFile.is_open())
	{
		return false;
	}

	HeaderAnalyzer headerAnalyzer;
	bool temp = HasIncludeGeneratedFile(headerPath);
	headerAnalyzer.SetIncludeRequired(HasIncludeGeneratedFile(headerPath));
	std::vector<std::string> reflectionDatas;

	if (!headerAnalyzer.Analyze(absolutePath, &reflectionDatas))
	{
		return false;
	}

	for (auto& c : macroPath)
	{
		if (c == ' ' || c == '\\' || c == '.' || c == '/')
		{
			c = '_';
		}
		else if (c >= 'a' && c <= 'z')
		{
			c -= 32;
		}
	}

	std::string generatedCode = "///Generated by Header Tool 0.1.2v\n\n";
	generatedCode += "#undef CURRENT_FILE_PATH\n";
	generatedCode += "#define CURRENT_FILE_PATH FTL_FILE_PATH_" + macroPath + "\n\n";
	//generatedCode += "#include \"../../Reflection/Reflection.h\"\n\n";

	// TODO: 리플렉션 데이터에 관련된 코드 생성 후 파일에 쓰기 구현
	headerFile.write(generatedCode.data(), generatedCode.size());

	std::string reflectionBodyMacro = "#define FTL_FILE_PATH_" + macroPath + "_";
	for (auto& reflectionData : reflectionDatas)
	{
		headerFile.write(reflectionBodyMacro.data(), reflectionBodyMacro.size());
		headerFile.write(reflectionData.data(), reflectionData.size());
		headerFile.write("\n", 1);
	}

	headerFile.close();

	AddIncludeGeneratedFile(headerPath);

	return true;
}

bool CodeGenerator::AddIncludeGeneratedFile(std::filesystem::path& headerPath)
{
	std::fstream headerFile(headerPath, std::ios::in | std::ios::out);
	if (!headerFile.is_open())
	{
		return false;
	}

	std::string includePrefix = "#include";

	headerFile.seekg(0, std::ios::end);
	size_t fileSize = headerFile.tellg();
	headerFile.seekg(0);
	std::string generatedHeaderName = "./generated/" + headerPath.stem().string() + "_generated.h";
	std::vector<char> buffer;
	buffer.reserve(fileSize);
	buffer.insert(buffer.end(), includePrefix.begin(), includePrefix.end());
	buffer.push_back(' ');
	buffer.push_back('\"');
	buffer.insert(buffer.end(), generatedHeaderName.begin(), generatedHeaderName.end());
	buffer.push_back('\"');
	buffer.push_back('\n');


	std::streampos lastInclude = headerFile.tellg();
	while (true)
	{
		std::string line;
		if (!std::getline(headerFile, line))
		{
			break;
		}

		if (line.find(includePrefix) != std::string::npos || line.find("#pragma once") != std::string::npos)
		{
			if (line.find(generatedHeaderName) != std::string::npos)
			{
				return false;
			}

			lastInclude = headerFile.tellg();
		}
	}
	headerFile.clear();
	headerFile.seekg(lastInclude);
	while (true)
	{
		std::string line;
		if (!std::getline(headerFile, line))
		{
			break;
		}
		buffer.insert(buffer.end(), line.begin(), line.end());
		buffer.push_back('\n');
	}

	headerFile.clear();
	headerFile.seekp(lastInclude);
	if (headerFile.tellp() != lastInclude)
	{
		int i = 0;

	}


	headerFile.write(buffer.data(), buffer.size());

	if (!headerFile.good())
	{
		int i = 0;
	}

	headerFile.flush();
	headerFile.close();

	return true;
}

bool CodeGenerator::HasIncludeGeneratedFile(std::filesystem::path& headerPath)
{
	std::fstream headerFile(headerPath, std::ios::in | std::ios::out);
	if (!headerFile.is_open())
	{
		return false;
	}

	std::string includePrefix = "#include";

	headerFile.seekg(0, std::ios::end);
	size_t fileSize = headerFile.tellg();
	headerFile.seekg(0);
	std::string generatedHeaderName = "./generated/" + headerPath.stem().string() + "_generated.h";
	std::vector<char> buffer;
	buffer.reserve(fileSize);
	buffer.insert(buffer.end(), includePrefix.begin(), includePrefix.end());
	buffer.push_back(' ');
	buffer.push_back('\"');
	buffer.insert(buffer.end(), generatedHeaderName.begin(), generatedHeaderName.end());
	buffer.push_back('\"');
	buffer.push_back('\n');

	std::streampos lastInclude = headerFile.tellg();
	while (true)
	{
		std::string line;
		if (!std::getline(headerFile, line))
		{
			break;
		}

		if (line.find(includePrefix) != std::string::npos || line.find("#pragma once") != std::string::npos)
		{
			if (line.find(generatedHeaderName) != std::string::npos)
			{
				return true;
			}

			//lastInclude = headerFile.tellg();
		}
	}

	return false;
}
